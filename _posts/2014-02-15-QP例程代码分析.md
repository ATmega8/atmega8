---
layout : post
title : QP例程代码分析
tag : 状态机
---

无奈QP下Linux例程太少，找了个win32/mingw/comp下的例程看。该目录下有 *alarm.c alarm.h  bsp.c  bsp.h  clock.h  comp.c* 几个源码文件。每个文件中的函数和数据结构如下:

* alarm.c：
  
  * static QState Alarm_initial(Alarm * const me, QEvt const * const e);                                       
  * static QState Alarm_off    (Alarm * const me, QEvt const * const e);                                       
  * static QState Alarm_on     (Alarm * const me, QEvt const * const e); 
  * void Alarm_ctor(Alarm * const me);

* comp.c：

  * struct：AlarmClockTag
  * typedef：AlarmClock
  * 变量:
	* static AlarmClock l_alarmClock;
	* static QEvt const *l_alarmClockQSto[10];
	* static QF_MPOOL_EL(TimeEvt) l_smlPoolSto[10];
	* QActive *APP_alarmClock= (QActive *)&l_alarmClock;
  * 函数：
	* void AlarmClock_ctor(AlarmClock * const me);
	* QState AlarmClock_initial(AlarmClock * const me, QEvt const * const e);
	* QState AlarmClock_final(AlarmClock * const me, QEvt const * const e);
	* QState AlarmClock_timekeeping(AlarmClock * const me, QEvt const * const e);
	* QState AlarmClock_mode24hr(AlarmClock * const me, QEvt const * const e);
	* QState AlarmClock_mode12hr(AlarmClock * const me, QEvt const * const e);
	* int main(int argc, char *argv[]);

有关Board Support Package（BSP）的函数均未列出。然后这些函数之间的关系是什么样的呢。首先，我们得找到一个入口。main函数是一个不错的选择。

~~~~~~~~~~~~~~~~~~~~~~~~ c
int main(int argc, char *argv[]) 
{
      printf("Orthogonal Component pattern\nQEP version: %s\nQF  version: %s\n"
             "Press 'o' to turn the Alarm ON\n"
             "Press 'f' to turn the Alarm OFF\n"
             "Press '0'..'9' to set the Alarm time\n"
             "Press 'a' to set the Clock in 12-hour mode\n"
             "Press 'b' to set the Clock in 24-hour mode\n"
             "Press ESC to quit...\n",
             QEP_getVersion(), QF_getVersion());
  
      BSP_init(argc, argv);                             /* initialize the BSP */
  
      QF_init();     /* initialize the framework and the underlying RT kernel */
  
      /* publish-subscribe not used, no call to QF_psInit() */
  
                                                 /* initialize event pools... */
      QF_poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0]));
  
                               /* instantiate and start the active objects... */
      AlarmClock_ctor(&l_alarmClock);
      QActive_start((QActive *)&l_alarmClock, 1,
                    l_alarmClockQSto, Q_DIM(l_alarmClockQSto),
                    (void *)0, 1024, (QEvt *)0);
  
      return QF_run();                              /* run the QF application */
}
~~~~~~~~~~~~~~~~~~~~~~~~

1. printf()函数是显示系统信息及操作方法。
2. BSP_init()函数是初始化系统底层接口。
3. QF_init()函数后面的注释上写的是初始化架构及底层实时内核。
4. QF_pollInit()函数是初始化事件池。
5. AlarmClock_ctor()函数是创建 *AlarmClock* 对象。
6. QActive_start()函数是启动活动对象。
7. QF_run()运行QF应用。

好，现在的问题就是要解决3，4，5，6，7这几个函数是干嘛的。除了5这个函数是用户定义的，其他都是QP的库函数。看前缀，3, 4, 7这三个函数是和QF有关的;6这个函数是和QActive有关的。那么QF和QActive是什么呢？在PSiCC里面找到了QActive是一个进程，而这个进程就运行在QF构架上。QActive由事件队列、事件循环和线程控制组成。
