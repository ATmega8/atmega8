---
 layout : post
 title : Codec2语音编码器2 编解码器初始化
 tag : Codec2
---

#### 函数 codec2\_create

编解码器的初始化自然就是初始化上节中介绍的各种数据类型。编解码器的初始化是由函数

{% highlight C %}

	struct CODEC2 * codec2_create(int mode)

{% endhighlight %}

完成。此函数定义在 *codec2.c* 中。
我们可以看到，此函数根据编解码器的模式返回一个对应的 **CODEC2** 结构体类型的指针。
那编解码器的模式呢？模式是一组宏定义，定义在 *codec2.h* 中。

{% highlight C %}

	#define CODEC2_MODE_3200 0
	#define CODEC2_MODE_2400 1
	#define CODEC2_MODE_1600 2
	#define CODEC2_MODE_1400 3
	#define CODEC2_MODE_1300 4
	#define CODEC2_MODE_1200 5
	#define CODEC2_MODE_700  6
	#define CODEC2_MODE_700B 7

{% endhighlight %}

这些模式代表着编解码器工作在不同的比特率上（bit/s）。
比如 **CODEC2\_MODE\_1200** 就应该编解码器是工作在1200bit/s的比特率上。

####函数的实现
{% highlight C %}

    struct CODEC2 *c2;
	int            i,l;

{% endhighlight %}

首先我们要定义一个 **CODEC2** 结构体类型的指针，然后定义两个局部变量。

{% highlight C %}

    c2 = (struct CODEC2*)malloc(sizeof(struct CODEC2));

	if (c2 == NULL)
	    return NULL;
		
{% endhighlight %}

接下来我们需要分配一片内存指向刚才定义的 **CODEC2** 结构体类型指针 **c2**。
如果分配失败了，那我们就返回 **NULL** 。分配完内存之后，我们就要往刚分配
的这片内存里填东西，因为我们不知道刚分配出来的这片内存里是什么，可能是0，
也可能是一些很奇怪的数字。

{% highlight C %}

	c2->mode = mode;

	for(i=0; i<M; i++)
		c2->Sn[i] = 1.0;

	c2->hpf_states[0] = c2->hpf_states[1] = 0.0;

	for(i=0; i<2*N; i++)
		c2->Sn_[i] = 0;

{% endhighlight %}

首先要把结构体中的 **mode** 初始化为函数的参数 **mode** 。
然后把结构体中输入语音数组的 **Sn** 的值初始化为 **1.0** 。
此处的常数 **M** 定义在 *defines.h* 中。表示基音分析帧的长度。
接下来我们把高通滤波器状态数组 **hpf\_state** 初始化为 **0.0** 。
最后我们初始化输出语音数组 **Sn\_** 的值为 **0.0** 。

接下来我们要初始化 FFT 配置结构体 **fft\_fwd\_cfg** 和 **fft\_inv\_cfg** 。

{% highlight C %}

    c2->fft_fwd_cfg = kiss_fft_alloc(FFT_ENC, 0, NULL, NULL);
	c2->fft_inv_cfg = kiss_fft_alloc(FFT_DEC, 1, NULL, NULL);

{% endhighlight %}

这两个结构体通过函数

{% highlight C %}
	kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem )
{% endhighlight %}

完成初始化。这个函数定义在 *kiss\_fft.c* 中。常量 **FFT\_ENC** 和 **FFT\_DEC** 定义在
 *defines.h* 中，表示 FFT 序列的长度。函数 **kiss\_fft\_alloc** 的第二个参数表示 FFT 为
正向 FFT 或者是 逆向 FFT 。如果是正向 FFT 用 0 表示，逆向 FFT 用 1 表示。 第三个参数 **mem**
是指向 FFT 缓冲区的指针，第四个参数 **lenmem** 是 FFT 缓冲区的大小。
这个函数的作用呢就是给 FFT 分配一些必要的储存空间。

接下来我们要初始化时域分析窗。通过函数 **make\_analysis\_window**。

{% highlight C %}
    make_analysis_window(c2->fft_fwd_cfg, c2->w,c2->W);
{% endhighlight %}

函数 **make\_analysis\_window** 定义在 *sine.c* 中。

{% highlight C %}
	void make_analysis_window(kiss_fft_cfg fft_fwd_cfg, float w[], COMP W[])
{% endhighlight %}

这个函数的作用是产生时域的分析窗以及分析窗的 DFT 。

