---
layout : post
title : PSiCC读书笔记
tag : 状态机
---

又是英文版，头痛。PSiCC的全称是 *Practical Statecharts in C/C++:Quantum Programming for Embedded Systems*。 把这本书啃完，状态机就差不多了吧。

####导论
所有的计算机系统都是事件驱动的，不管是通用的还是特殊的嵌入式系统，这就意味着它们在不断的等待事件的发生。我们把可以用一个实时方法处理很多异步事件的简洁程序程序架构叫做事件驱动编程。

####反向控制
比如说一个程序要实现了按钮按下输出高电平这个功能。

* 传统程序的控制流：按下按键，产生一个按键外部中断，然后在中断处理程序里面实现输出高电平。
* 事件驱动程序的控制流:按下按键，产生一个外部中断，事件驱动核收到这个中断，调用一个程序输出高电平。

传统程序的控制权一直都是在应用程序中的，是由应用程序来调用别的程序。而事件驱动程序的控制权是在事件驱动核中，是由事件驱动核去调用别的程序。这个就是"Don't call us, we'll call you"的意思吧。

这样做的结果是：

1.自然的分开内核和应用。

2.控制权颠倒。

3.事件驱动应用必须反过来控制之后处理的每个事件，所以进程上下文不能保存在栈中而且程序指针（PC）作为一个顺序程序。所以，事件驱动程序成为一个状态机。


####在C语言中使用面向对象编程
尽管QP/C是基于ANSI-C标准实现的，但是QP/C中广泛的使用了面向对象设计原则，例如封装（类）和单继承。在C语言层面上，封装和继承变得只是简单的编程习惯用语，本节将简要介绍它。

#####封装
封装是把数据和操作包装成类的能力。在C语言中，你可以把这些数据表示为一个结构体，对于使用这些数据的函数的第一个参数作为指向数据结构体的指针。例如，类 *QMsm* 包装了状态机数据和对此数据操作的函数。这个类的C语言声明如下：

~~~~~~~~~~~~~~~~~~~~ c
typedef struct QMsmTag
{
	QMsmVtbl const *vptr;
	QMAttr state;
	QMAttr temp;
} QMsm;

void QMsm_ctor(QMsm *const me, QStateHandler initial);
void QMsm_init(QMsm *const me, QEvt const *const e);
void QMsm_dispatch(QMsm *const me, QEvt const *const e);
~~~~~~~~~~~~~~~~~~~~

正如你所见，QP/C采用了一些编码和命名规则，进一步的要求加强对数据结构和操作它的函数之间的关联：

* 类型定义为类名的数据结构上保持了结构体的类属性，为了方便访问，它作为 *QMsm* 而不是 *struct QMsm*。

* 每个类函数名都以前缀 *QMsm_* 开始，以表明该函数所属的类。

* 每个类函数总是将指向 *QMsm* 结构体的指针作为第一个参数，它总是叫做 *me* 。

* 每个类提供了一个特殊函数用来初始化类属性，这个函数叫做 *QMsm_ctor*。 它起着构造一个类的作用。

#####继承
继承是为了获得基于现有类的新类而重用和组织现有代码的能力。你可以在C语言中十分简单的实现单继承，通过从字面上嵌入基类结构体作为派生结构体的第一个元素。例如，图1![图1](/image/FA1.jpg)表示结构体 *ScoreEvt* 通过嵌入基类结构体 *QEvt* 作为其第一个元素而继承 *QEvt*。为了使这个习惯用法更好的脱颖而出，在QP/C基结构体成员始终被命名为 *super* 。
